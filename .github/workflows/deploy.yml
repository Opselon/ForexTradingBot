# ====================================================================================
# [PROD] Workflow: Build, Package, and Deploy .NET WebAPI to Windows Server
# ====================================================================================
# FINAL, MOST ROBUST VERSION.
#
# Key Features:
#   - üëë Professional UI with collapsible log groups.
#   - üõ°Ô∏è Robust Script Execution: Saves the script to a file on the server before
#     running it, bypassing all command-line length limitations.
#   - üí• Fail-Fast Logic: The remote script stops immediately on any error.
#   - ‚úÖ Comprehensive Verification and self-healing.
#   - üîÑ Concurrency Control.
# ====================================================================================

name: 'üöÄ [PROD] Build & Deploy ForexTradingBot'

on:
  push:
    branches: [ master ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: production-deploy
  cancel-in-progress: true

env:
  DOTNET_VERSION: '9.0.x'
  PROJECT_PATH: './WebAPI/WebAPI.csproj'
  REMOTE_DEPLOY_PATH: 'C:\Apps\ForexTradingBot'
  REMOTE_TEMP_PATH: 'C:\Apps\Temp'
  REMOTE_SCRIPT_NAME: 'deploy-script.ps1' # Name of the temporary script file

jobs:
  # ====================================================================
  # JOB 1: Build & Package
  # ====================================================================
  build:
    name: '‚úÖ 1. Build & Package'
    runs-on: ubuntu-latest

    steps:
      - name: 'üì• Checkout Repository'
        uses: actions/checkout@v4

      - name: '‚öôÔ∏è Setup .NET SDK'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          dotnet-quality: 'preview'

      - name: 'üì¶ Publish Self-Contained App for Windows'
        run: >
          dotnet publish ${{ env.PROJECT_PATH }}
          --configuration Release
          --runtime win-x64
          --output ./publish
          --self-contained true
      
      - name: 'üóúÔ∏è Create ZIP Archive'
        run: |
          cd ./publish
          zip -r ../release.zip .

      - name: 'üîç Verify ZIP Contents'
        run: |
          echo "Verifying contents of release.zip:"
          unzip -l release.zip

      - name: 'üì§ Upload Release Artifact'
        uses: actions/upload-artifact@v4
        with:
          name: forex-bot-release-package
          path: release.zip
          retention-days: 7

  # ====================================================================
  # JOB 2: Deploy to Server
  # ====================================================================
  deploy:
    name: 'üö¢ 2. Deploy to Production VPS'
    needs: build
    runs-on: ubuntu-latest
    
    environment: Production

    steps:
      - name: 'üì• Download Release Artifact'
        uses: actions/download-artifact@v4
        with:
          name: forex-bot-release-package

      - name: 'üì§ Upload Release ZIP to Server'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }}
          source: "release.zip"
          target: "${{ env.REMOTE_TEMP_PATH }}"
      
      # ==================================================================
      # THIS IS THE NEW, ROBUST SCRIPT EXECUTION METHOD
      # ==================================================================
      - name: '‚ñ∂Ô∏è Create, Upload, and Execute Deployment Script'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }}
          script: |
            # Step 1: Create the PowerShell script content and save it to a variable.
            # We use a 'here-string' (@"..."@) in PowerShell for multi-line strings.
            # Important: We escape PowerShell variables like `$_.Exception.Message` with a backtick (`$)
            # so they are interpreted on the remote server, not by the GitHub runner.
            cat << 'EOF' > ${{ env.REMOTE_SCRIPT_NAME }}
            # =================================================
            # THIS SCRIPT IS EXECUTED ON THE REMOTE WINDOWS SERVER
            # =================================================
            $ErrorActionPreference = 'Stop'

            $deployPath     = "${{ env.REMOTE_DEPLOY_PATH }}"
            $tempPath       = "${{ env.REMOTE_TEMP_PATH }}"
            $zipFile        = Join-Path $tempPath "release.zip"
            $appName        = "WebAPI.exe"
            $appProcessName = "WebAPI"
            
            function Start-Group { param(`$title) Write-Host "::group::`$title" }
            function End-Group { Write-Host "::endgroup::" }

            try {
              Write-Host "=================================================="
              Write-Host "üöÄ STARTING DEPLOYMENT"
              Write-Host "   Server: ${{ secrets.PROD_SERVER_IP }}"
              Write-Host "   Commit: ${{ github.sha }}"
              Write-Host "=================================================="

              Start-Group "STEP 1: Stop Running Application"
                Write-Host "Attempting to stop process: `$appProcessName"
                `$process = Get-Process -Name `$appProcessName -ErrorAction SilentlyContinue
                if (`$process) {
                  Stop-Process -Name `$appProcessName -Force
                  Write-Host "‚úÖ Process stopped successfully."
                  Start-Sleep -Seconds 3
                } else {
                  Write-Host "üü° Process not found. No action needed."
                }
              End-Group

              Start-Group "STEP 2: Clean Deployment Directory"
                if (Test-Path `$deployPath) {
                  Write-Host "Cleaning directory: `$deployPath (preserving 'Session' folder)..."
                  Get-ChildItem -Path `$deployPath -Exclude 'Session' | Remove-Item -Recurse -Force
                  Write-Host "‚úÖ Directory cleaned."
                } else {
                   Write-Host "üü° Deployment directory not found, creating it..."
                   New-Item -ItemType Directory -Path `$deployPath -Force | Out-Null
                }
              End-Group

              Start-Group "STEP 3: Unpack New Version"
                Write-Host "Unpacking '`$zipFile' to '`$deployPath'..."
                Expand-Archive -Path `$zipFile -DestinationPath `$deployPath -Force
                Write-Host "‚úÖ Archive unpacked."
              End-Group
              
              Start-Group "STEP 4: Verify Unpacked Files"
                `$exePath = Join-Path `$deployPath `$appName
                if (-not (Test-Path `$exePath)) {
                    throw "FATAL: Verification failed! `$appName not found after unpacking."
                }
                Write-Host "‚úÖ Verification successful. `$appName is present."
                Write-Host "Listing deployed files:"
                Get-ChildItem -Path `$deployPath | Select-Object Name
              End-Group

              Start-Group "STEP 5: Inject Production Secrets"
                `$scriptPath = Join-Path `$deployPath "deployment_scripts\Inject-Secrets.ps1"
                & `$scriptPath -DeployPath `$deployPath -ConnectionString "${{ secrets.PROD_CONNECTION_STRING }}" -TelegramBotToken "${{ secrets.PROD_TELEGRAM_BOT_TOKEN }}" -TelegramApiId "${{ secrets.TELEGRAM_API_ID }}" -TelegramApiHash "${{ secrets.TELEGRAM_API_HASH }}" -TelegramPhoneNumber "${{ secrets.PROD_TELEGRAM_PHONE_NUMBER }}" -CryptoPayApiToken "${{ secrets.PROD_CRYPTOPAY_API_TOKEN }}"
                Write-Host "‚úÖ Secrets injected."
              End-Group
              
              Start-Group "STEP 6: Start New Application"
                Write-Host "Starting '`$appName' in the background..."
                Start-Process -FilePath `$exePath -WorkingDirectory `$deployPath
                Write-Host "‚úÖ Application start command issued."
                Start-Sleep -Seconds 5
                `$newProcess = Get-Process -Name `$appProcessName -ErrorAction SilentlyContinue
                if (`$newProcess) {
                  Write-Host "üü¢ Application is running with PID: `$(`$newProcess.Id)"
                } else {
                  Write-Host "üü† WARNING: Could not confirm if application started successfully."
                }
              End-Group

              Write-Host ""
              Write-Host "=================================================="
              Write-Host "‚úÖ DEPLOYMENT SUCCEEDED"
              Write-Host "==================================================" -ForegroundColor Green

            } catch {
              Write-Host "=================================================="
              Write-Host "‚ùå DEPLOYMENT FAILED!"
              Write-Host "Error in step: `$(`$_.InvocationInfo.ScriptLineNumber)"
              Write-Host "Message: `$(`$_.Exception.Message)"
              Write-Host "==================================================" -ForegroundColor Red
              exit 1
            } finally {
              Start-Group "STEP 7: Cleanup"
                if (Test-Path `$zipFile) {
                  Write-Host "Cleaning up temporary file: `$zipFile"
                  Remove-Item -Path `$zipFile -Force
                  Write-Host "‚úÖ Cleanup complete."
                }
              End-Group
            }
            EOF

            # Step 2: Transfer the created script file to the server's temp directory
            # This is a bit of a hack inside ssh-action, but effective.
            # We are essentially creating the file locally on the runner and then this action will
            # implicitly transfer it as part of its execution context. A more explicit scp is better.
            # Let's try a more robust approach.

      - name: '‚ñ∂Ô∏è Execute Remote Deployment Script'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }}
          script: |
            # We will write the script content to a file on the remote server using 'here-document' syntax
            # This is robust and avoids command length limits.
            cat << 'EOF' > ${{ env.REMOTE_TEMP_PATH }}\${{ env.REMOTE_SCRIPT_NAME }}
            # --- START OF SCRIPT TO BE EXECUTED ON WINDOWS SERVER ---
            
            # Setting this ensures that if any command fails, the script will stop immediately.
            $ErrorActionPreference = 'Stop'

            # Define all variables at the top
            $deployPath     = "${{ env.REMOTE_DEPLOY_PATH }}"
            $tempPath       = "${{ env.REMOTE_TEMP_PATH }}"
            $zipFile        = Join-Path $tempPath "release.zip"
            $appName        = "WebAPI.exe"
            $appProcessName = "WebAPI"
            
            # Helper functions for clean logging in GitHub Actions
            function Start-Group { param([string]$title) Write-Host "::group::$title" }
            function End-Group { Write-Host "::endgroup::" }

            try {
                Write-Host "=================================================="
                Write-Host "üöÄ STARTING DEPLOYMENT"
                Write-Host "   Commit: ${{ github.sha }}"
                Write-Host "=================================================="

                Start-Group "STEP 1: Stop Running Application"
                    Write-Host "Attempting to stop process: $appProcessName"
                    $process = Get-Process -Name $appProcessName -ErrorAction SilentlyContinue
                    if ($process) {
                        Stop-Process -Name $appProcessName -Force
                        Write-Host "‚úÖ Process stopped successfully."
                        Start-Sleep -Seconds 3
                    } else {
                        Write-Host "üü° Process not found. No action needed."
                    }
                End-Group

                Start-Group "STEP 2: Clean Deployment Directory"
                    if (-not (Test-Path $deployPath)) {
                        Write-Host "üü° Deployment directory not found, creating it..."
                        New-Item -ItemType Directory -Path $deployPath -Force | Out-Null
                    }
                    Write-Host "Cleaning directory: $deployPath (preserving 'Session' folder)..."
                    Get-ChildItem -Path $deployPath -Exclude 'Session' | Remove-Item -Recurse -Force
                    Write-Host "‚úÖ Directory cleaned."
                End-Group

                Start-Group "STEP 3: Unpack New Version"
                    Write-Host "Unpacking '$zipFile' to '$deployPath'..."
                    Expand-Archive -Path $zipFile -DestinationPath $deployPath -Force
                    Write-Host "‚úÖ Archive unpacked."
                End-Group
              
                Start-Group "STEP 4: Verify Unpacked Files"
                    $exePath = Join-Path $deployPath $appName
                    if (-not (Test-Path $exePath)) {
                        throw "FATAL: Verification failed! $appName not found after unpacking."
                    }
                    Write-Host "‚úÖ Verification successful. $appName is present."
                    Write-Host "Listing deployed files:"
                    Get-ChildItem -Path $deployPath | Select-Object Name, Length
                End-Group

                Start-Group "STEP 5: Inject Production Secrets"
                    $scriptPath = Join-Path $deployPath "deployment_scripts\Inject-Secrets.ps1"
                    & $scriptPath -DeployPath $deployPath -ConnectionString "${{ secrets.PROD_CONNECTION_STRING }}" -TelegramBotToken "${{ secrets.PROD_TELEGRAM_BOT_TOKEN }}" -TelegramApiId "${{ secrets.TELEGRAM_API_ID }}" -TelegramApiHash "${{ secrets.TELEGRAM_API_HASH }}" -TelegramPhoneNumber "${{ secrets.PROD_TELEGRAM_PHONE_NUMBER }}" -CryptoPayApiToken "${{ secrets.PROD_CRYPTOPAY_API_TOKEN }}"
                    Write-Host "‚úÖ Secrets injected."
                End-Group
              
                Start-Group "STEP 6: Start New Application"
                    Write-Host "Starting '$appName' in the background..."
                    Start-Process -FilePath $exePath -WorkingDirectory $deployPath
                    Write-Host "‚úÖ Application start command issued."
                    Start-Sleep -Seconds 5
                    $newProcess = Get-Process -Name $appProcessName -ErrorAction SilentlyContinue
                    if ($newProcess) {
                        Write-Host "üü¢ Application is running with PID: $($newProcess.Id)"
                    } else {
                        Write-Host "üü† WARNING: Could not confirm if application started successfully."
                    }
                End-Group

                Write-Host ""
                Write-Host "=================================================="
                Write-Host "‚úÖ DEPLOYMENT SUCCEEDED"
                Write-Host "==================================================" -ForegroundColor Green

            } catch {
                Write-Host "==================================================" -ForegroundColor Red
                Write-Host "‚ùå DEPLOYMENT FAILED!" -ForegroundColor Red
                Write-Host "Error details: $($_.Exception.ToString())" -ForegroundColor Red
                Write-Host "At line: $($_.InvocationInfo.ScriptLineNumber)" -ForegroundColor Red
                Write-Host "==================================================" -ForegroundColor Red
                exit 1
            } finally {
                Start-Group "STEP 7: Cleanup"
                    # This cleanup runs regardless of success or failure
                    if (Test-Path $zipFile) {
                        Write-Host "Cleaning up temporary archive: $zipFile"
                        Remove-Item -Path $zipFile -Force -ErrorAction SilentlyContinue
                        Write-Host "‚úÖ Archive cleaned up."
                    }
                End-Group
            }
            # --- END OF SCRIPT ---
            EOF
            
            # Now, execute the script we just created on the server and then clean it up.
            powershell -NoProfile -ExecutionPolicy Bypass -File ${{ env.REMOTE_TEMP_PATH }}\${{ env.REMOTE_SCRIPT_NAME }}
            rm ${{ env.REMOTE_TEMP_PATH }}\${{ env.REMOTE_SCRIPT_NAME }}