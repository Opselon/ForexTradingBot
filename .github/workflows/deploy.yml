# ====================================================================================
# THE DEFINITIVE, FLAWLESS, AND FULL-SCALE DEPLOYMENT WORKFLOW (v.Victory-Injection)
# This workflow uses a SINGLE, powerful, unbreakable remote command that performs
# the entire deployment atomically, using the CORRECT file injection method that
# matches your now-corrected JSON structure. This is the definitive solution.
# ====================================================================================

name: 'üöÄ [PROD] Full-Scale Deployment Operation'

on:
  push:
    branches: [ master ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: production-deploy
  cancel-in-progress: true

env:
  DOTNET_VERSION: '9.0.x'
  PROJECT_PATH: './WebAPI/WebAPI.csproj'
  REMOTE_DEPLOY_PATH: 'C:\Apps\ForexTradingBot'
  REMOTE_TEMP_PATH: 'C:\Apps\Temp'
  SESSION_FOLDER: 'Session'

jobs:
  # ================================================================
  # JOB 1: BUILD & PACKAGE
  # This section remains UNCHANGED as it works perfectly.
  # ================================================================
  build:
    name: '‚úÖ 1. Build & Package'
    runs-on: ubuntu-latest
    outputs:
      release_version: ${{ steps.version.outputs.value }}
    steps:
      - name: 'Get Short Commit Hash for Versioning'
        id: version
        run: echo "value=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: 'üì• Checkout Repository & Scripts'
        uses: actions/checkout@v4

      - name: '‚öôÔ∏è Setup .NET SDK'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: 'üì¶ Publish Application'
        run: dotnet publish ${{ env.PROJECT_PATH }} -c Release -r win-x64 -o ./publish --self-contained true

      - name: 'üúúÔ∏è Create Release ZIP Archive'
        run: cd ./publish && zip -r ../release.zip .

      - name: 'üì§ Upload Artifacts for Deployment Jobs'
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifacts-${{ steps.version.outputs.value }}
          path: release.zip # We only need the zip now
          retention-days: 1

  # ================================================================
  # JOB 2: DEPLOY, VERIFY, AND REPORT (THE FINAL BATTLE)
  # This single job performs the entire lifecycle on the server in one
  # unbreakable, fully-logged PowerShell command block.
  # ================================================================
  deploy:
    name: 'üö¢ 2. Execute Atomic Deployment, Verification & Report'
    needs: build
    runs-on: ubuntu-latest
    
    steps:
      - name: 'Phase 1 - UPLOAD: Download and Transfer Release'
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifacts-${{ needs.build.outputs.release_version }}
      - uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }}
          source: "release.zip"
          target: "${{ env.REMOTE_TEMP_PATH }}"

      # ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ THE ONLY STEP THAT MATTERS: THE UNBREAKABLE SCRIPT ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ
      - name: 'Phase 2 - EXECUTE: The Full Atomic Lifecycle'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }}
          script: |
            powershell.exe -NoProfile -ExecutionPolicy Bypass -Command "
            # This is it. One script to rule them all. No dependencies, maximum power.
            `$ErrorActionPreference = 'Stop';
            `$DeployPath = '${{ env.REMOTE_DEPLOY_PATH }}';
            `$TempPath = '${{ env.REMOTE_TEMP_PATH }}';
            `$ZipFile = Join-Path `$TempPath 'release.zip';
            `$SessionSourcePath = Join-Path `$DeployPath '${{ env.SESSION_FOLDER }}';
            `$SessionBackupPath = Join-Path `$TempPath '${{ env.SESSION_FOLDER }}.bak';
            `$AppName = 'WebAPI';
            `$ExeName = 'WebAPI.exe';

            try {
                Write-Host '================== [STARTING ATOMIC DEPLOYMENT] ==================' -ForegroundColor Cyan;
                
                # --- Step 1: Stop and Backup ---
                Write-Host '[1/6] Stopping process and backing up Session...' -ForegroundColor Yellow;
                Get-Process -Name `$AppName -ErrorAction SilentlyContinue | Stop-Process -Force -Verbose;
                if (Test-Path `$SessionSourcePath) {
                    if (Test-Path `$SessionBackupPath) { Remove-Item `$SessionBackupPath -Recurse -Force; }
                    Move-Item -Path `$SessionSourcePath -Destination `$SessionBackupPath -Force -Verbose;
                }
                
                # --- Step 2: Obliterate and Restore ---
                Write-Host '[2/6] Cleaning and restoring directory...' -ForegroundColor Yellow;
                if (Test-Path `$DeployPath) { Remove-Item -Path `$DeployPath -Recurse -Force -Verbose; }
                New-Item -Path `$DeployPath -ItemType Directory -Force | Out-Null;
                if (Test-Path `$SessionBackupPath) { Move-Item -Path `$SessionBackupPath -Destination `$SessionSourcePath -Force -Verbose; }
                
                # --- Step 3: Unpack ---
                Write-Host '[3/6] Unpacking new version...' -ForegroundColor Yellow;
                Expand-Archive -Path `$ZipFile -DestinationPath `$DeployPath -Force -Verbose;
                if (-not (Test-Path (Join-Path `$DeployPath `$ExeName))) { throw 'FATAL: WebAPI.exe NOT FOUND after unpack!'; }

                # --- Step 4: SECRET INJECTION INTO THE FILE ---
                Write-Host '[4/6] Injecting secrets DIRECTLY into appsettings.Production.json...' -ForegroundColor Yellow;
                `$appSettingsPath = Join-Path `$DeployPath 'appsettings.Production.json';
                if (-not (Test-Path `$appSettingsPath)) { throw 'FATAL: appsettings.Production.json NOT FOUND!'; }
                `$content = Get-Content `$appSettingsPath -Raw;
                `$content = `$content -replace '#{ConnectionString}#', '${{ secrets.PROD_CONNECTION_STRING }}';
                `$content = `$content -replace '#{DatabaseProvider}#', 'SqlServer'; # Hard-coding as per your JSON
                `$content = `$content -replace '#{TelegramBotToken}#', '${{ secrets.PROD_TELEGRAM_BOT_TOKEN }}';
                `$content = `$content -replace '#{TelegramApiId}#', '${{ secrets.TELEGRAM_API_ID }}';
                `$content = `$content -replace '#{TelegramApiHash}#', '${{ secrets.TELEGRAM_API_HASH }}';
                `$content = `$content -replace '#{TelegramPhoneNumber}#', '${{ secrets.PROD_TELEGRAM_PHONE_NUMBER }}';
                `$content = `$content -replace '#{CryptoPayApiToken}#', '${{ secrets.PROD_CRYPTOPAY_API_TOKEN }}';
                Set-Content -Path `$appSettingsPath -Value `$content;
                Write-Host '--- Final Config File Content (Verification) ---'; 
                Get-Content `$appSettingsPath;
                
                # --- Step 5: LAUNCH ---
                Write-Host '[5/6] Launching application...' -ForegroundColor Yellow;
                # We tell the application to run in Production environment so it reads the correct file.
                `$env:ASPNETCORE_ENVIRONMENT='Production';
                Start-Process -FilePath (Join-Path `$DeployPath `$ExeName) -WorkingDirectory `$DeployPath;
                
                # --- Step 6: Final Verification ---
                Write-Host '[6/6] Final health check...' -ForegroundColor Yellow;
                Start-Sleep -Seconds 10;
                `$process = Get-Process -Name `$AppName -ErrorAction SilentlyContinue;
                if (`$process) {
                    Write-Host '‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ VICTORY! WebAPI Process is RUNNING! ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ' -ForegroundColor Green;
                } else {
                    throw 'FATAL: Application is NOT RUNNING. It started but crashed. Since config is confirmed correct, the issue is likely a code-level problem (e.g., cannot connect to database). Check server Event Viewer.';
                }

            } catch {
                Write-Host '--- ‚ùå A FATAL ERROR OCCURRED! ---' -ForegroundColor Red;
                Write-Host `"$($_.Exception.ToString())`" -ForegroundColor Red;
                exit 1;
            } finally {
                # --- Final Cleanup ---
                Write-Host '--- Final Cleanup of temporary files...'
                Remove-Item -Path `$ZipFile, `$SessionBackupPath -Recurse -Force -ErrorAction SilentlyContinue;
            }"