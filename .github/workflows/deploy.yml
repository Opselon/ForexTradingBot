# ====================================================================================
# [PROD] Workflow: Build, Package, and Deploy .NET WebAPI to Windows Server
# ====================================================================================
# This workflow automates the deployment of the ForexTradingBot to the production
# server using a secure password-based connection.
#
# Trigger:
#   - Pushing to the 'master' branch.
#   - Manual trigger via the 'workflow_dispatch' event.
#
# Key Features:
#   - ✅ Robust: Fails immediately if any step on the server encounters an error.
#   - ✅ Atomic: Prevents multiple concurrent deployments.
#   - ✅ Verifiable: Includes verification steps to confirm success.
#   - ✅ Maintainable: Clean, well-commented, and uses environment variables.
# ====================================================================================

name: '[PROD] Build and Deploy ForexTradingBot'

on:
  push:
    branches: [ master ]
  workflow_dispatch:

# --- Security & Concurrency Best Practices ---
permissions:
  contents: read

concurrency:
  group: production-deploy
  cancel-in-progress: true

# --- Environment Variables ---
env:
  DOTNET_VERSION: '9.0.x'
  PROJECT_PATH: './WebAPI/WebAPI.csproj'
  REMOTE_DEPLOY_PATH: 'C:\Apps\ForexTradingBot'
  REMOTE_TEMP_PATH: 'C:\Apps\Temp'

jobs:
  # ====================================================================
  # JOB 1: Build & Package
  # ====================================================================
  build:
    name: '✅ 1. Build & Package Application'
    runs-on: ubuntu-latest

    steps:
      - name: '📥 Checkout Repository'
        uses: actions/checkout@v4

      - name: '⚙️ Setup .NET SDK'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          dotnet-quality: 'preview'

      - name: '🚀 Publish Self-Contained App for Windows'
        run: >
          dotnet publish ${{ env.PROJECT_PATH }}
          --configuration Release
          --runtime win-x64
          --output ./publish
          --self-contained true
      
      - name: '📦 Create ZIP Archive'
        run: |
          cd ./publish
          zip -r ../release.zip .

      - name: '🔍 Verify ZIP Contents'
        run: unzip -l release.zip

      - name: '📤 Upload Release Artifact'
        uses: actions/upload-artifact@v4
        with:
          name: forex-bot-release-package
          path: release.zip
          retention-days: 7

  # ====================================================================
  # JOB 2: Deploy to Server
  # ====================================================================
  deploy:
    name: '🚢 2. Deploy to Windows VPS'
    needs: build
    runs-on: ubuntu-latest
    
    environment: Production

    steps:
      - name: '📥 Download Release Artifact'
        uses: actions/download-artifact@v4
        with:
          name: forex-bot-release-package

      - name: '📤 Upload Release ZIP to Server'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }} # <-- Using password
          source: "release.zip"
          target: "${{ env.REMOTE_TEMP_PATH }}"
          
      - name: '🚀 Execute Remote Deployment Script'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }} # <-- Using password

          script: |
            powershell -NoProfile -ExecutionPolicy Bypass -Command {
              # This script runs on the remote Windows server.
              $ErrorActionPreference = 'Stop' # Critical: script will fail on any error.

              $deployPath = "${{ env.REMOTE_DEPLOY_PATH }}"
              $tempPath = "${{ env.REMOTE_TEMP_PATH }}"
              $zipFile = Join-Path $tempPath "release.zip"
              $appName = "WebAPI.exe"
              $appProcessName = "WebAPI"

              try {
                Write-Host "--- Starting Deployment Script on Server ---" -ForegroundColor Cyan

                # Step 1: Ensure directories exist
                Write-Host "[1/7] Ensuring target directories exist..."
                New-Item -ItemType Directory -Path $deployPath -Force | Out-Null
                New-Item -ItemType Directory -Path $tempPath -Force | Out-Null
                
                # Step 2: Stop the running application
                Write-Host "[2/7] Stopping running application ($appProcessName)..."
                $process = Get-Process -Name $appProcessName -ErrorAction SilentlyContinue
                if ($process) {
                  Stop-Process -Name $appProcessName -Force
                  Write-Host "Process stopped successfully."
                } else {
                  Write-Host "Process not found. No action needed." -ForegroundColor Yellow
                }
                Start-Sleep -Seconds 3

                # Step 3: Clean the deployment directory (excluding 'Session')
                Write-Host "[3/7] Cleaning deployment directory..."
                Get-ChildItem -Path $deployPath -Exclude 'Session' | Remove-Item -Recurse -Force
                Write-Host "Directory cleaned."
                
                # Step 4: Unpack the new version
                Write-Host "[4/7] Unpacking '$zipFile' to '$deployPath'..."
                Expand-Archive -Path $zipFile -DestinationPath $deployPath -Force
                
                # Step 5: Verify unpack was successful by checking for the .exe
                Write-Host "[5/7] Verifying unpacked files..."
                if (-not (Test-Path (Join-Path $deployPath $appName))) {
                    throw "Verification failed! $appName not found after unpacking."
                }
                Write-Host "Verification successful. $appName is present."

                # Step 6: Inject production secrets
                Write-Host "[6/7] Injecting production secrets..."
                $scriptPath = Join-Path $deployPath "deployment_scripts\Inject-Secrets.ps1"
                & $scriptPath -DeployPath $deployPath -ConnectionString "${{ secrets.PROD_CONNECTION_STRING }}" -TelegramBotToken "${{ secrets.PROD_TELEGRAM_BOT_TOKEN }}" -TelegramApiId "${{ secrets.TELEGRAM_API_ID }}" -TelegramApiHash "${{ secrets.TELEGRAM_API_HASH }}" -TelegramPhoneNumber "${{ secrets.PROD_TELEGRAM_PHONE_NUMBER }}" -CryptoPayApiToken "${{ secrets.PROD_CRYPTOPAY_API_TOKEN }}"
                Write-Host "Secrets injected."
                
                # Step 7: Start the new application
                Write-Host "[7/7] Starting the new application..."
                # Using cmd's start command to run in the background without waiting
                cmd /c "cd /d $deployPath && start /b $appName"
                Write-Host "Application start command issued."
                
                Write-Host "--- ✅ Deployment Successful! ---" -ForegroundColor Green

              } catch {
                Write-Host "--- ❌ DEPLOYMENT FAILED! ---" -ForegroundColor Red
                Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
                # Exit with a non-zero code to fail the GitHub Action job
                exit 1
              } finally {
                # Cleanup: Always remove the temporary zip file
                if (Test-Path $zipFile) {
                  Write-Host "Cleaning up temporary file '$zipFile'..."
                  Remove-Item -Path $zipFile -Force
                }
              }
            }