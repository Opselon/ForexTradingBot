# ====================================================================================
# THE ABSOLUTE, DEFINITIVE, FLAWLESS WORKFLOW (v.Syntax-Perfected)
# This workflow uses the robust Atomic Deployment script with syntactically correct
# YAML, ensuring the workflow itself is as unbreakable as the deployment logic.
# This is the definitive solution.
# ====================================================================================

name: 'üöÄ [PROD] Deploy, Inject & Verify'

on:
  push:
    branches: [ master ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: production-deploy
  cancel-in-progress: true

env:
  DOTNET_VERSION: '9.0.x'
  PROJECT_PATH: './WebAPI/WebAPI.csproj'
  REMOTE_DEPLOY_PATH: 'C:\Apps\ForexTradingBot'
  REMOTE_TEMP_PATH: 'C:\Apps\Temp'
  SESSION_FOLDER: 'Session'

jobs:
  build_and_package:
    name: '‚úÖ 1. Build & Package'
    runs-on: ubuntu-latest
    steps:
      - name: 'üì• Checkout Repository'
        uses: actions/checkout@v4
        
      - name: '‚öôÔ∏è Setup .NET SDK'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}
          
      - name: 'üì¶ Publish Application'
        run: dotnet publish ${{ env.PROJECT_PATH }} -c Release -r win-x64 -o ./publish --self-contained true
        
      - name: 'üóúÔ∏è Create Release ZIP Archive'
        run: cd ./publish && zip -r ../release.zip .
        
      - name: 'üì§ Upload Artifact'
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: release.zip
          retention-days: 1

  deploy_and_verify:
    name: 'üö¢ 2. Full Atomic Deployment & Verification'
    needs: build_and_package
    runs-on: ubuntu-latest
    
    steps:
      - name: 'üì• Download Release Artifact'
        uses: actions/download-artifact@v4
        with:
          name: deployment-package

      - name: 'üì§ [Step 1/8] Upload Release ZIP to Server'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }}
          source: "release.zip"
          target: "${{ env.REMOTE_TEMP_PATH }}"

      # ======================== ATOMIC DEPLOYMENT SCRIPT ========================
      # ‚úÖ‚úÖ‚úÖ THIS IS THE SYNTACTICALLY CORRECTED STEP ‚úÖ‚úÖ‚úÖ
      - name: '‚ñ∂Ô∏è [Steps 2-8] Execute Full Deployment Lifecycle'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_SERVER_USERNAME }}
          password: ${{ secrets.PROD_SERVER_PASSWORD }}
          # The entire script is now a single block literal string.
          # This is the most robust way to pass multi-line scripts in YAML.
          script: |
            powershell.exe -NoProfile -ExecutionPolicy Bypass -Command "
            $ErrorActionPreference = 'Stop';
            $DeployPath = '${{ env.REMOTE_DEPLOY_PATH }}';
            $TempPath = '${{ env.REMOTE_TEMP_PATH }}';
            $ZipFile = Join-Path $TempPath 'release.zip';
            $SessionSourcePath = Join-Path $DeployPath '${{ env.SESSION_FOLDER }}';
            $SessionBackupPath = Join-Path $TempPath '${{ env.SESSION_FOLDER }}.bak';
            $AppCrashLogFile = Join-Path $TempPath 'App-Crash-Log.txt';
            $AppName = 'WebAPI';
            $ExeName = 'WebAPI.exe';

            try {
                # --- [START OF ATOMIC DEPLOYMENT] ---
                Write-Host '================== [STARTING DEPLOYMENT] ==================' -ForegroundColor Cyan;
                
                Write-Host '[2/8] Stopping any running process...' -ForegroundColor Yellow;
                Get-Process -Name $AppName -ErrorAction SilentlyContinue | Stop-Process -Force -Verbose;
                
                Write-Host '[3/8] Backing up Session folder...' -ForegroundColor Yellow;
                if (Test-Path $SessionSourcePath) {
                    if (Test-Path $SessionBackupPath) { Remove-Item $SessionBackupPath -Recurse -Force; }
                    Move-Item -Path $SessionSourcePath -Destination $SessionBackupPath -Force -Verbose;
                } else { Write-Host 'No existing Session folder to back up.'; }
                
                Write-Host '[4/8] OBLITERATING old deployment directory...' -ForegroundColor Yellow;
                if (Test-Path $DeployPath) { Remove-Item -Path $DeployPath -Recurse -Force -Verbose; }
                New-Item -Path $DeployPath -ItemType Directory -Force | Out-Null;
                if (Test-Path $SessionBackupPath) {
                    Move-Item -Path $SessionBackupPath -Destination $SessionSourcePath -Force -Verbose;
                    Write-Host 'Session folder restored.';
                }
                
                Write-Host '[5/8] Unpacking new version into clean directory...' -ForegroundColor Yellow;
                Expand-Archive -Path $ZipFile -DestinationPath $DeployPath -Force -Verbose;
                if (-not (Test-Path (Join-Path $DeployPath $ExeName))) { throw 'FATAL: WebAPI.exe NOT FOUND after unpack!'; }

                Write-Host '[6/8] Injecting secrets DIRECTLY into appsettings.Production.json...' -ForegroundColor Yellow;
                $appSettingsPath = Join-Path $DeployPath 'appsettings.Production.json';
                if (-not (Test-Path $appSettingsPath)) { throw 'FATAL: appsettings.Production.json NOT FOUND after unpack!'; }
                (Get-Content $appSettingsPath -Raw) -replace '#{ConnectionString}#', '${{ secrets.PROD_CONNECTION_STRING }}' -replace '#{TelegramBotToken}#', '${{ secrets.PROD_TELEGRAM_BOT_TOKEN }}' -replace '#{TelegramApiId}#', '${{ secrets.TELEGRAM_API_ID }}' -replace '#{TelegramApiHash}#', '${{ secrets.TELEGRAM_API_HASH }}' -replace '#{TelegramPhoneNumber}#', '${{ secrets.PROD_TELEGRAM_PHONE_NUMBER }}' -replace '#{CryptoPayApiToken}#', '${{ secrets.PROD_CRYPTOPAY_API_TOKEN }}' | Set-Content -Path $appSettingsPath;
                Write-Host '--- Final Config File Content ---';
                Get-Content $appSettingsPath;
                
                Write-Host '[7/8] Launching application with crash logging...' -ForegroundColor Yellow;
                $Launcher = Join-Path $DeployPath 'start-app.bat';
                $BatContent = ""@echo off`ncd /d `"`$DeployPath`"`n`"`$ExeName`"`" > `"`$AppCrashLogFile`"`" 2>&1"";
                Set-Content -Path $Launcher -Value $BatContent;
                Start-Process -FilePath 'cmd.exe' -ArgumentList ""/c `"`"`$Launcher`"`"" -WindowStyle Hidden;
                
                Write-Host '[8/8] Final Health Check after 10 seconds...' -ForegroundColor Yellow;
                Start-Sleep -Seconds 10;
                $process = Get-Process -Name $AppName -ErrorAction SilentlyContinue;
                if ($process) {
                    Write-Host '‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ ULTIMATE SUCCESS! WebAPI Process is RUNNING! ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ' -ForegroundColor Green;
                } else {
                    Write-Host '‚ùå‚ùå‚ùå FAILURE: WebAPI process is NOT RUNNING.' -ForegroundColor Red;
                    Write-Host '--- CRASH LOG ---';
                    Get-Content $AppCrashLogFile -ErrorAction SilentlyContinue;
                    throw 'Application crashed on startup.';
                }

            } catch {
                Write-Host '--- ‚ùå A FATAL ERROR OCCURRED! ---' -ForegroundColor Red;
                Write-Host $_.Exception.ToString();
                exit 1;
            } finally {
                Write-Host '--- Final Cleanup ---';
                Remove-Item -Path $ZipFile, $SessionBackupPath -Recurse -Force -ErrorAction SilentlyContinue;
            }"